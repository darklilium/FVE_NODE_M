(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(['exports', 'react', 'react-dom', '../constants/keyCodes', '../utils/StringUtils/getDisplayName', '../utils/EventUtils/captureNextEvent'], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require('react'), require('react-dom'), require('../constants/keyCodes'), require('../utils/StringUtils/getDisplayName'), require('../utils/EventUtils/captureNextEvent'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.react, global.reactDom, global.keyCodes, global.getDisplayName, global.captureNextEvent);
    global.injectTooltip = mod.exports;
  }
})(this, function (exports, _react, _reactDom, _keyCodes, _getDisplayName, _captureNextEvent) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _react2 = _interopRequireDefault(_react);

  var _getDisplayName2 = _interopRequireDefault(_getDisplayName);

  var _captureNextEvent2 = _interopRequireDefault(_captureNextEvent);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  function _objectWithoutProperties(obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var CONTEXT_TIMEOUT = 687;

  /**
   * Takes any component and injects a tooltip when the user hovers
   * over the component or touch holds it on a mobile device. It also
   * injects the event listeners and a `tooltip` prop to be added to
   * the `ComposedComponent`.
   *
   * If the `tooltipLabel` prop is omitted, the tooltip and event listeners will not
   * be included.
   *
   * ```js
   * @param {function} ComposedComponent the component to compose with the tooltip functionality.
   * @return {function} the ComposedComponent with a tooltip.
   * ```
   */

  exports.default = function (ComposedComponent) {
    var _class, _temp;

    return _temp = _class = function (_PureComponent) {
      _inherits(TooltipedComponent, _PureComponent);

      function TooltipedComponent(props, context) {
        _classCallCheck(this, TooltipedComponent);

        var _this = _possibleConstructorReturn(this, (TooltipedComponent.__proto__ || Object.getPrototypeOf(TooltipedComponent)).call(this, props, context));

        _this.getComposedComponent = _this.getComposedComponent.bind(_this);
        _this._setComposedComponent = _this._setComposedComponent.bind(_this);
        _this._showTooltip = _this._showTooltip.bind(_this);
        _this._handleBlur = _this._handleBlur.bind(_this);
        _this._handleKeyUp = _this._handleKeyUp.bind(_this);
        _this._handleMouseOver = _this._handleMouseOver.bind(_this);
        _this._handleMouseLeave = _this._handleMouseLeave.bind(_this);
        _this._handleTouchEnd = _this._handleTouchEnd.bind(_this);
        _this._handleTouchStart = _this._handleTouchStart.bind(_this);
        _this._handleContextMenu = _this._handleContextMenu.bind(_this);
        return _this;
      }

      _createClass(TooltipedComponent, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
          this._component = (0, _reactDom.findDOMNode)(this);
        }

        /**
         * Gets the composed component as a ref. This is usefull if you need to access the ref of the
         * composed component instead of the `injectInk` HOC to use some publically accessible methods.
         *
         * ```js
         * <SomeInkedComponent
         *   ref={inkHOC => {
         *     inkHOC.getComposedComponent().focus();
         *   }}
         * />
         * ```
         */

      }, {
        key: 'getComposedComponent',
        value: function getComposedComponent() {
          return this._composed;
        }
      }, {
        key: '_setComposedComponent',
        value: function _setComposedComponent(component) {
          this._composed = component;
        }

        /**
         * Takes a tooltip target container and attempts to find the tooltip container inside. It will only
         * check the direct children.
         *
         * @param {DOMNode} container the container node to check.
         * @return {DOMNode} the tooltip container node or null.
         */

      }, {
        key: '_getTooltipContainer',
        value: function _getTooltipContainer(container) {
          return Array.prototype.slice.call(container.childNodes).filter(function (node) {
            return node.className && node.className.indexOf('md-tooltip-container') !== -1;
          })[0];
        }

        /**
         * Attempts to find a tooltip container inside the given container element. If it does not
         * exist, a new tooltip container will be created and inserted as the first child in
         * the main container.
         *
         * @param {DOMNode} container the container node to check.
         * @return {DOMNode} the existing or newly created tooltip container node.
         */

      }, {
        key: '_getOrCreateTooltipContainer',
        value: function _getOrCreateTooltipContainer(container) {
          var tooltipContainer = this._getTooltipContainer(container);

          if (!tooltipContainer) {
            tooltipContainer = document.createElement('div');
            tooltipContainer.className = 'md-tooltip-container';

            container.insertBefore(tooltipContainer, container.firstChild);
          }

          return tooltipContainer;
        }
      }, {
        key: '_showTooltip',
        value: function _showTooltip() {
          var _this2 = this;

          if (this._shown) {
            return;
          }

          var _props = this.props,
              tooltipLabel = _props.tooltipLabel,
              tooltipPosition = _props.tooltipPosition;

          var container = this._getOrCreateTooltipContainer(this._component);

          var tooltip = document.createElement('span');
          var horizontal = ['top', 'bottom'].indexOf(tooltipPosition) !== -1;
          var position = 'md-tooltip--' + (horizontal ? 'horizontal' : 'vertical') + ' md-tooltip--' + tooltipPosition;
          tooltip.className = 'md-tooltip ' + position + ' md-tooltip--enter';
          tooltip.innerHTML = tooltipLabel;

          container.insertBefore(tooltip, null);

          this._timeout = setTimeout(function () {
            tooltip.classList.add('md-tooltip--active');
            tooltip.classList.add('md-tooltip--enter-active');
            tooltip.classList.add('md-tooltip--' + tooltipPosition + '-active');
            _this2._timeout = setTimeout(function () {
              _this2._timeout = null;

              tooltip.classList.remove('md-tooltip--active');
              tooltip.classList.remove('md-tooltip--enter');
              tooltip.classList.remove('md-tooltip--enter-active');
            }, 150);
          }, 10);

          this._shown = true;
        }
      }, {
        key: '_hideTooltip',
        value: function _hideTooltip() {
          var _this3 = this;

          if (!this._shown) {
            return;
          }

          if (this._timeout) {
            clearTimeout(this._timeout);
          }

          var container = this._getOrCreateTooltipContainer(this._component);
          var tooltip = container.childNodes[0];
          tooltip.classList.add('md-tooltip--active');
          tooltip.classList.add('md-tooltip--leave');
          this._timeout = setTimeout(function () {
            tooltip.classList.remove('md-tooltip--' + _this3.props.tooltipPosition + '-active');
            tooltip.classList.add('md-tooltip--leave-active');

            _this3._timeout = setTimeout(function () {
              _this3._timeout = null;
              _this3._shown = false;

              container.removeChild(tooltip);
            }, 150);
          }, 1);
        }
      }, {
        key: '_handleBlur',
        value: function _handleBlur(e) {
          if (this.props.onBlur) {
            this.props.onBlur(e);
          }

          this._hideTooltip();
        }
      }, {
        key: '_handleKeyUp',
        value: function _handleKeyUp(e) {
          if (this.props.onKeyUp) {
            this.props.onKeyUp(e);
          }

          if ((e.which || e.keyCode) === _keyCodes.TAB) {
            this._showTooltip();
          }
        }
      }, {
        key: '_handleMouseOver',
        value: function _handleMouseOver(e) {
          var _this4 = this;

          var _props2 = this.props,
              onMouseOver = _props2.onMouseOver,
              tooltipDelay = _props2.tooltipDelay;

          if (onMouseOver) {
            onMouseOver(e);
          }

          if (this._touched) {
            return;
          }

          if (this._delayedTimeout) {
            clearTimeout(this._delayedTimeout);
          }

          if (tooltipDelay) {
            this._delayedTimeout = setTimeout(function () {
              _this4._delayedTimeout = null;
              _this4._showTooltip();
            }, tooltipDelay);
          } else {
            this._showTooltip();
          }
        }
      }, {
        key: '_handleMouseLeave',
        value: function _handleMouseLeave(e) {
          if (this.props.onMouseLeave) {
            this.props.onMouseLeave(e);
          }

          if (this._touched) {
            return;
          }

          if (this._delayedTimeout) {
            clearTimeout(this._delayedTimeout);
          }

          this._hideTooltip();
        }
      }, {
        key: '_handleTouchStart',
        value: function _handleTouchStart(e) {
          var _this5 = this;

          if (this.props.onTouchStart) {
            this.props.onTouchStart(e);
          }

          if (this._timeout) {
            clearTimeout(this._timeout);
          }

          this._timeout = setTimeout(function () {
            _this5._timeout = null;
            (0, _captureNextEvent2.default)('click');
            _this5._showTooltip();
          }, CONTEXT_TIMEOUT);
          this._touched = true;
          window.addEventListener('contextmenu', this._handleContextMenu);
        }
      }, {
        key: '_handleTouchEnd',
        value: function _handleTouchEnd(e) {
          var _this6 = this;

          if (this.props.onTouchEnd) {
            this.props.onTouchEnd(e);
          }

          window.removeEventListener('contextmenu', this._handleContextMenu);

          if (this._timeout) {
            clearTimeout(this._timeout);
            this._timeout = null;
          } else {
            e.preventDefault();
          }

          this._timeout = setTimeout(function () {
            _this6._timeout = null;
            _this6._touched = false;
            _this6._hideTooltip();
          }, 1500);
        }
      }, {
        key: '_handleContextMenu',
        value: function _handleContextMenu(e) {
          e.preventDefault();
        }
      }, {
        key: 'render',
        value: function render() {
          var _props3 = this.props,
              tooltipLabel = _props3.tooltipLabel,
              props = _objectWithoutProperties(_props3, ['tooltipLabel']);

          delete props.tooltipPosition;
          delete props.tooltipDelay;
          props.ref = this._setComposedComponent;

          if (!tooltipLabel) {
            return _react2.default.createElement(ComposedComponent, props);
          }

          return _react2.default.createElement(ComposedComponent, _extends({}, props, {
            ref: this._setComposedComponent,
            onMouseOver: this._handleMouseOver,
            onMouseLeave: this._handleMouseLeave,
            onKeyUp: this._handleKeyUp,
            onBlur: this._handleBlur,
            onTouchStart: this._handleTouchStart,
            onTouchEnd: this._handleTouchEnd
          }));
        }
      }]);

      return TooltipedComponent;
    }(_react.PureComponent), _class.displayName = (0, _getDisplayName2.default)(ComposedComponent, 'Tooltiped'), _class.propTypes = {
      /**
       * The tooltip to display.
       */
      tooltipLabel: _react.PropTypes.string,

      /**
       * The position of the tooltip relative to the `ComposedComponent`.
       */
      tooltipPosition: _react.PropTypes.oneOf(['top', 'right', 'bottom', 'left']).isRequired,

      /**
       * An optional delay before the tooltip appears on hover or keyboard focus. The
       * touch tooltip will always appear at `687ms` (~ time for context menu).
       */
      tooltipDelay: _react.PropTypes.number,

      /**
       * An optional function to call when the composed component triggers the `blur` event.
       */
      onBlur: _react.PropTypes.func,

      /**
       * An optional function to call when the composed component triggers the `keyup` event.
       */
      onKeyUp: _react.PropTypes.func,

      /**
       * An optional function to call when the composed component triggers the `mouseover` event.
       */
      onMouseOver: _react.PropTypes.func,

      /**
       * An optional function to call when the composed component triggers the `mouseleave` event.
       */
      onMouseLeave: _react.PropTypes.func,

      /**
       * An optional function to call when the composed component triggers the `touchstart` event.
       */
      onTouchStart: _react.PropTypes.func,

      /**
       * An optional function to call when the composed component triggers the `touchend` event.
       */
      onTouchEnd: _react.PropTypes.func
    }, _class.defaultProps = {
      tooltipPosition: 'bottom'
    }, _temp;
  };
});